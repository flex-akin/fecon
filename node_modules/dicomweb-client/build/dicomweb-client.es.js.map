{"version":3,"file":"dicomweb-client.es.js","sources":["../src/message.js","../src/api.js","../src/utils.js","../src/version.js","../src/dicomweb-client.js"],"sourcesContent":["/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = \"\";\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split(\"\\r\\n\");\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === \"--\") {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = \"application/dicom\"\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength + footerLength;\n\n    return contentArray;\n  });\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  const message = new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array(\"\\r\\n\\r\\n\");\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error(\"Response message has no multipart mime header\");\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error(\"Header of response message does not specify boundary\");\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error(\"Response message part has no mime header\");\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid\n};\n","import { multipartEncode, multipartDecode } from \"./message.js\";\n\nfunction isObject(obj) {\n  return typeof obj === \"object\" && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid = Array.isArray(requestHooks) && requestHooks.every(requestHook => \n    typeof requestHook === 'function'\n      && requestHook.length === 2\n  );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n      'function requestHook(request, metadata) { return request; }'\n    );\n  }\n\n  return isValid;\n}\n\nconst getFirstResult = result => result[0];\nconst getFirstResultIfLengthGtOne = result => {\n  if (result.length > 1) {\n    return result;\n  }\n\n  return result[0]\n};\n\nconst MEDIATYPES = {\n  DICOM: \"application/dicom\",\n  DICOM_JSON: \"application/dicom+json\",\n  OCTET_STREAM: \"application/octet-stream\",\n  PDF: \"application/pdf\",\n  JPEG: \"image/jpeg\",\n  PNG: \"image/png\"\n};\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String} options.username - Username\n   * @param {String} options.password - Password\n   * @param {Object} options.headers - HTTP headers\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @param {Object} options.verbose - print to console request warnings and errors, default true\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error(\"no DICOMweb base url provided - calls will fail\");\n    }\n\n    if (\"username\" in options) {\n      this.username = options.username;\n      if (!(\"password\" in options)) {\n        console.error(\n          \"no password provided to authenticate with DICOMweb service\"\n        );\n      }\n      this.password = options.password;\n    }\n\n    if (\"qidoURLPrefix\" in options) {\n      console.log(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if (\"wadoURLPrefix\" in options) {\n      console.log(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if (\"stowURLPrefix\" in options) {\n      console.log(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if (\"requestHooks\" in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || function() {};\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose === false ? false : true;\n  }\n\n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = \"?\";\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += \"&\";\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Object} options\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, options = {}) {\n\n    const { errorInterceptor, requestHooks } = this;\n\n    return new Promise((resolve, reject) => {\n      let request = new XMLHttpRequest();\n\n      request.open(method, url, true);\n      if (\"responseType\" in options) {\n        request.responseType = options.responseType;\n      }\n\n      if (typeof headers === \"object\") {\n        Object.keys(headers).forEach(key => {\n          request.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        request.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      request.onloadstart = function onloadstart() {\n        // console.log('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      request.onloadend = function onloadend() {\n        // console.log('upload finished')\n      };\n\n      // Handle response message\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status === 200) {\n            resolve(request.response);\n          } else if (request.status === 202) {\n            if (this.verbose) {\n              console.warn(\"some resources already existed: \", request);\n            }\n            resolve(request.response);\n          } else if (request.status === 204) {\n            if (this.verbose) {\n              console.warn(\"empty response for request: \", request);\n            }\n            resolve([]);\n          } else {\n            const error = new Error(\"request failed\");\n            error.request = request;\n            error.response = request.response;\n            error.status = request.status;\n            if (this.verbose) {\n              console.error(\"request failed: \", request);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if (\"progressCallback\" in options) {\n        if (typeof options.progressCallback === \"function\") {\n          request.onprogress = options.progressCallback;\n        }\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) { \n        const headers = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers };\n        const pipeRequestHooks = functions => (args) => functions.reduce((args, fn) => fn(args, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        request = pipedRequest(request);\n      }\n\n      // Add withCredentials to request if needed\n      if (\"withCredentials\" in options) {\n        if (options.withCredentials) {\n          request.withCredentials = true;\n        }\n      }\n\n      if (\"data\" in options) {\n        request.send(options.data);\n      } else {\n        request.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Object} responseType\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n    return this._httpRequest(url, \"get\", headers, {\n      responseType,\n      progressCallback,\n      withCredentials\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === \"object\") {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n    const responseType = \"json\";\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === \"object\") {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n    const responseType = \"json\";\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(url, mediaTypes, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === \"object\") {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      \"image/\",\n      \"image/*\",\n      \"image/jpeg\",\n      \"image/jp2\",\n      \"image/gif\",\n      \"image/png\"\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = \"arraybuffer\";\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetText(url, mediaTypes, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === \"object\") {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      \"text/\",\n      \"text/*\",\n      \"text/html\",\n      \"text/plain\",\n      \"text/rtf\",\n      \"text/xml\"\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = \"arraybuffer\";\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(url, mediaTypes, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === \"object\") {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      \"video/\",\n      \"video/*\",\n      \"video/mpeg\",\n      \"video/mp4\",\n      \"video/H265\"\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = \"arraybuffer\";\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf(\"/\");\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = [\"application\", \"image\", \"text\", \"video\"];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes(\"/\")) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        \"image/jpeg\",\n        \"image/gif\",\n        \"image/png\",\n        \"image/jp2\"\n      ];\n    } else {\n      supportedMediaTypes = {\n        \"1.2.840.10008.1.2.5\": [\"image/x-dicom-rle\"],\n        \"1.2.840.10008.1.2.4.50\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.51\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.57\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.70\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.80\": [\"image/x-jls\", \"image/jls\"],\n        \"1.2.840.10008.1.2.4.81\": [\"image/x-jls\", \"image/jls\"],\n        \"1.2.840.10008.1.2.4.90\": [\"image/jp2\"],\n        \"1.2.840.10008.1.2.4.91\": [\"image/jp2\"],\n        \"1.2.840.10008.1.2.4.92\": [\"image/jpx\"],\n        \"1.2.840.10008.1.2.4.93\": [\"image/jpx\"]\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes\n    );\n\n    return this._httpGet(url, headers, \"arraybuffer\", progressCallback, withCredentials).then(\n      multipartDecode\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        \"video/\",\n        \"video/*\",\n        \"video/mpeg2\",\n        \"video/mp4\",\n        \"video/H265\"\n      ];\n    } else {\n      supportedMediaTypes = {\n        \"1.2.840.10008.1.2.4.100\": [\"video/mpeg2\"],\n        \"1.2.840.10008.1.2.4.101\": [\"video/mpeg2\"],\n        \"1.2.840.10008.1.2.4.102\": [\"video/mp4\"],\n        \"1.2.840.10008.1.2.4.103\": [\"video/mp4\"],\n        \"1.2.840.10008.1.2.4.104\": [\"video/mp4\"],\n        \"1.2.840.10008.1.2.4.105\": [\"video/mp4\"],\n        \"1.2.840.10008.1.2.4.106\": [\"video/mp4\"]\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes\n    );\n\n    return this._httpGet(url, headers, \"arraybuffer\", progressCallback, withCredentials).then(\n      multipartDecode\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(url, mediaTypes, params, progressCallback, withCredentials) {\n    const headers = {};\n    const defaultMediaType = \"application/dicom\";\n    const supportedMediaTypes = {\n      \"1.2.840.10008.1.2.1\": [defaultMediaType],\n      \"1.2.840.10008.1.2.5\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.50\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.51\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.57\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.70\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.80\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.81\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.90\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.91\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.92\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.93\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.100\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.101\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.102\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.103\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.104\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.105\": [defaultMediaType],\n      \"1.2.840.10008.1.2.4.106\": [defaultMediaType]\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes\n    );\n\n    return this._httpGet(url, headers, \"arraybuffer\", progressCallback, withCredentials).then(\n      multipartDecode\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a application/octet-stream media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    progressCallback,\n    withCredentials\n  ) {\n    const headers = {};\n    const defaultMediaType = \"application/octet-stream\";\n    const supportedMediaTypes = {\n      \"1.2.840.10008.1.2.1\": [defaultMediaType]\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes\n    );\n\n    return this._httpGet(url, headers, \"arraybuffer\", progressCallback, withCredentials).then(\n      multipartDecode\n    );\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, progressCallback, withCredentials) {\n    return this._httpRequest(url, \"post\", headers, {\n      data,\n      progressCallback,\n      withCredentials\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n    const headers = { \"Content-Type\": MEDIATYPES.DICOM_JSON };\n    return this._httpPost(url, headers, data, progressCallback, withCredentials);\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split(\"/\");\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error(\"Acceptable media types must be provided as an Array\");\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(\", \");\n  }\n\n  /**\n     * Builds an accept header field value for HTTP GET multipart request\n     messages.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types\n     * @param {Object[]} supportedMediaTypes - Supported media types\n     * @private\n     */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error(\"Acceptable media types must be provided as an Array\");\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        \"Supported media types must be provided as an Array or an Object\"\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (!Object.values(supportedMediaTypes).flat(1).includes(mediaType)) {\n          if (!mediaType.endsWith(\"/*\") || !mediaType.endsWith(\"/\")) {\n            throw new Error(\n              `Media type ${mediaType} is not supported for requested resource`\n            );\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== \"*\") {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                  const expectedType = DICOMwebClient._parseMediaType(\n                    expectedMediaType\n                  )[0];\n                  const haveSameType = actualType === expectedType;\n\n                  if (\n                    haveSameType &&\n                    (mediaType.endsWith(\"/*\") || mediaType.endsWith(\"/\"))\n                  ) {\n                    return;\n                  }\n\n                  throw new Error(\n                    `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`\n                  );\n              })\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`\n        );\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    return fieldValueParts.join(\", \");\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return \"bytes=0-\";\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types)\n  }\n\n  /**\n   * Gets common type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error(\"No acceptable media types provided\");\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error(\"No common acceptable media type could be identified.\");\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error(\"Acceptable media types must have the same type.\");\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    console.log(\"search for studies\");\n    let withCredentials = false;\n    let url = `${this.qidoURL}/studies`;\n    if (\"queryParams\" in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {Object} studyInstanceUID - Study Instance UID\n   * @returns {Object[]} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of study metadata\"\n      );\n    }\n    console.log(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if (\"studyInstanceUID\" in options) {\n      console.log(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += \"/series\";\n    if (\"queryParams\" in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} options.studyInstanceUID - Study Instance UID\n   * @param {Object} options.seriesInstanceUID - Series Instance UID\n   * @returns {Object[]} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of series metadata\"\n      );\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\n        \"Series Instance UID is required for retrieval of series metadata\"\n      );\n    }\n\n    console.log(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/metadata`;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    let withCredentials = false;\n    if (\"studyInstanceUID\" in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if (\"seriesInstanceUID\" in options) {\n        console.log(\n          `search for instances of series ${options.seriesInstanceUID}`\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        console.log(\n          `search for instances of study ${options.studyInstanceUID}`\n        );\n      }\n    } else {\n      console.log(\"search for instances\");\n    }\n    url += \"/instances\";\n    if (\"queryParams\" in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {Object} options.studyInstanceUID - Study Instance UID\n   * @param {Object} options.seriesInstanceUID - Series Instance UID\n   * @param {Object} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\"Study Instance UID is required.\");\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\"Series Instance UID is required.\");\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\"SOP Instance UID is required.\");\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || \"*\";\n    const params = [];\n\n    params.push(\"requestType=WADO\");\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join(\"&\");\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Object} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of instance metadata\"\n      );\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\n        \"Series Instance UID is required for retrieval of instance metadata\"\n      );\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\n        \"SOP Instance UID is required for retrieval of instance metadata\"\n      );\n    }\n    console.log(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${options.sopInstanceUID}/metadata`;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of instance frames\"\n      );\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\n        \"Series Instance UID is required for retrieval of instance frames\"\n      );\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\n        \"SOP Instance UID is required for retrieval of instance frames\"\n      );\n    }\n    if (!(\"frameNumbers\" in options)) {\n      throw new Error(\n        \"frame numbers are required for retrieval of instance frames\"\n      );\n    }\n    console.log(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url, false, false, false, progressCallback, withCredentials\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        \"1.2.840.10008.1.2.1\": [\"application/octet-stream\"],\n        \"1.2.840.10008.1.2.5\": [\"image/x-dicom-rle\"],\n        \"1.2.840.10008.1.2.4.50\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.51\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.57\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.70\": [\"image/jpeg\"],\n        \"1.2.840.10008.1.2.4.80\": [\"image/x-jls\", \"image/jls\"],\n        \"1.2.840.10008.1.2.4.81\": [\"image/x-jls\", \"image/jls\"],\n        \"1.2.840.10008.1.2.4.90\": [\"image/jp2\"],\n        \"1.2.840.10008.1.2.4.91\": [\"image/jp2\"],\n        \"1.2.840.10008.1.2.4.92\": [\"image/jpx\"],\n        \"1.2.840.10008.1.2.4.93\": [\"image/jpx\"],\n      }\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes\n        )\n      }\n      return this._httpGet(\n        url, headers, \"arraybuffer\", progressCallback, withCredentials\n      ).then(multipartDecode);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith(\"application\")) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url, mediaTypes, false, false, progressCallback, withCredentials\n      );\n    } else if (commonMediaType.startsWith(\"image\")) {\n      return this._httpGetMultipartImage(\n        url, mediaTypes, false, false, false, progressCallback, withCredentials\n      );\n    } else if (commonMediaType.startsWith(\"video\")) {\n      return this._httpGetMultipartVideo(\n        url, mediaTypes, false, false, false, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`\n    );\n  }\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String[]} [options.mediaType] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of rendered instance\"\n      );\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\n        \"Series Instance UID is required for retrieval of rendered instance\"\n      );\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\n        \"SOP Instance UID is required for retrieval of rendered instance\"\n      );\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = \"arraybuffer\";\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, progressCallback, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith(\"image\")) {\n      return this._httpGetImage(\n        url, mediaTypes, queryParams, progressCallback, withCredentials\n      );\n    } else if (commonMediaType.startsWith(\"video\")) {\n      return this._httpGetVideo(\n        url, mediaTypes, queryParams, progressCallback, withCredentials\n      );\n    } else if (commonMediaType.startsWith(\"text\")) {\n      return this._httpGetText(\n        url, mediaTypes, queryParams, progressCallback, withCredentials\n      );\n    } else if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url, queryParams, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n      'for retrieval of rendered instance.'\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String[]} [options.mediaType] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of rendered instance\"\n      );\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\n        \"Series Instance UID is required for retrieval of rendered instance\"\n      );\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\n        \"SOP Instance UID is required for retrieval of rendered instance\"\n      );\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = \"arraybuffer\";\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url, headers, responseType, progressCallback, withCredentials\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith(\"image\")) {\n      return this._httpGetImage(\n        url, mediaTypes, queryParams, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n      'for retrieval of rendered instance.'\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {String[]} [options.mediaType] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of rendered instance frames\"\n      );\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\n        \"Series Instance UID is required for retrieval of rendered instance frames\"\n      );\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\n        \"SOP Instance UID is required for retrieval of rendered instance frames\"\n      );\n    }\n    if (!(\"frameNumbers\" in options)) {\n      throw new Error(\n        \"frame numbers are required for retrieval of rendered instance frames\"\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = \"arraybuffer\";\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, false, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith(\"image\")) {\n      return this._httpGetImage(\n        url, mediaTypes, queryParams, progressCallback, withCredentials\n      );\n    } else if (commonMediaType.startsWith(\"video\")) {\n      return this._httpGetVideo(\n        url, mediaTypes, queryParams, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n      'for retrieval of rendered frame.'\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\n        \"Study Instance UID is required for retrieval of rendered instance frames\"\n      );\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\n        \"Series Instance UID is required for retrieval of rendered instance frames\"\n      );\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\n        \"SOP Instance UID is required for retrieval of rendered instance frames\"\n      );\n    }\n    if (!(\"frameNumbers\" in options)) {\n      throw new Error(\n        \"frame numbers are required for retrieval of rendered instance frames\"\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = \"arraybuffer\";\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url, headers, responseType, progressCallback, withCredentials\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith(\"image\")) {\n      return this._httpGetImage(\n        url, mediaTypes, queryParams, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n      'for retrieval of rendered frame.'\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {ArrayBuffer} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\"Study Instance UID is required\");\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\"Series Instance UID is required\");\n    }\n    if (!(\"sopInstanceUID\" in options)) {\n      throw new Error(\"SOP Instance UID is required\");\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url, false, false, progressCallback, withCredentials\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url, mediaTypes, false, progressCallback, withCredentials\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\"Study Instance UID is required\");\n    }\n    if (!(\"seriesInstanceUID\" in options)) {\n      throw new Error(\"Series Instance UID is required\");\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url, false, false, progressCallback, withCredentials\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url, mediaTypes, false, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!(\"studyInstanceUID\" in options)) {\n      throw new Error(\"Study Instance UID is required\");\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url, false, false, progressCallback, withCredentials\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url, mediaTypes, false, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {String} BulkDataURI - URI for retrieval of bulkdata\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!(\"BulkDataURI\" in options)) {\n      throw new Error(\"BulkDataURI is required.\");\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if (\"progressCallback\" in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        byteRange,\n        false, false, withCredentials\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType === MEDIATYPES.OCTET_STREAM) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        byteRange,\n        false, progressCallback, withCredentials\n      );\n    } else if (commonMediaType.startsWith(\"image\")) {\n      return this._httpGetMultipartImage(\n        url, mediaTypes, byteRange, false, false, progressCallback, withCredentials\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of bulk data.`\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!(\"datasets\" in options)) {\n      throw new Error(\"datasets are required for storing\");\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if (\"studyInstanceUID\" in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      \"Content-Type\": `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`\n    };\n    let withCredentials = false;\n    if (\"withCredentials\" in options) {\n      if(options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpPost(\n      url, headers, data, options.progressCallback, withCredentials\n    );\n  }\n}\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n","function findSubstring(str, before, after) {\n  const beforeIndex = str.lastIndexOf(before) + before.length;\n  if (beforeIndex < before.length) {\n    return null;\n  }\n  if (after !== undefined) {\n    const afterIndex = str.lastIndexOf(after);\n    if (afterIndex < 0) {\n      return null;\n    }\n    return str.substring(beforeIndex, afterIndex);\n  }\n  return str.substring(beforeIndex);\n}\n\nfunction getStudyInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, \"studies/\", \"/series\");\n  if (!uid) {\n    uid = findSubstring(uri, \"studies/\");\n  }\n  if (!uid) {\n    console.debug(\n      `Study Instance UID could not be dertermined from URI \"${uri}\"`\n    );\n  }\n  return uid;\n}\n\nfunction getSeriesInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, \"series/\", \"/instances\");\n  if (!uid) {\n    uid = findSubstring(uri, \"series/\");\n  }\n  if (!uid) {\n    console.debug(\n      `Series Instance UID could not be dertermined from URI \"${uri}\"`\n    );\n  }\n  return uid;\n}\n\nfunction getSOPInstanceUIDFromUri(uri) {\n  let uid = findSubstring(uri, \"/instances/\", \"/frames\");\n  if (!uid) {\n    uid = findSubstring(uri, \"/instances/\", \"/metadata\");\n  }\n  if (!uid) {\n    uid = findSubstring(uri, \"/instances/\");\n  }\n  if (!uid) {\n    console.debug(`SOP Instance UID could not be dertermined from URI\"${uri}\"`);\n  }\n  return uid;\n}\n\nfunction getFrameNumbersFromUri(uri) {\n  let numbers = findSubstring(uri, \"/frames/\", \"/rendered\");\n  if (!numbers) {\n    numbers = findSubstring(uri, \"/frames/\");\n  }\n  if (numbers === undefined) {\n    console.debug(`Frames Numbers could not be dertermined from URI\"${uri}\"`);\n  }\n  return numbers.split(\",\");\n}\n\nexport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri\n};\n","export default \"0.5.2\";\n","import { DICOMwebClient } from \"./api.js\";\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri\n} from \"./utils.js\";\n\nconst api = {\n  DICOMwebClient\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri\n};\n\nexport { default as version } from \"./version.js\";\n\nexport { api, utils };\n"],"names":["uint8ArrayToString","arr","offset","limit","itemLimit","length","str","i","String","fromCharCode","stringToUint8Array","Uint8Array","j","charCodeAt","identifyBoundary","header","parts","split","substr","containsToken","message","token","index","findToken","maxSearchLength","searchLength","Math","min","guid","s4","floor","random","toString","substring","multipartEncode","datasets","boundary","contentType","contentTypeString","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","map","datasetBuffer","contentArray","contentLength","multipartArray","set","position","forEach","data","buffer","multipartDecode","response","separator","headerIndex","Error","boundaryString","boundaryLength","components","boundaryIndex","headerTokenIndex","spacingLength","slice","push","isObject","obj","isEmptyObject","Object","keys","constructor","areValidRequestHooks","requestHooks","isValid","Array","isArray","every","requestHook","console","warn","getFirstResult","result","MEDIATYPES","DICOM","DICOM_JSON","OCTET_STREAM","PDF","JPEG","PNG","DICOMwebClient","options","baseURL","url","error","username","password","log","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","headers","errorInterceptor","verbose","method","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","key","setRequestHeader","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","progressCallback","onprogress","assign","metadata","pipeRequestHooks","functions","args","reduce","fn","pipedRequest","withCredentials","send","_httpRequest","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGet","mediaTypes","supportedMediaTypes","acceptHeaderFieldValue","_buildAcceptHeaderFieldValue","byteRange","rendered","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","then","defaultMediaType","acceptableMediaTypes","mediaType","_httpPost","queryParams","_httpGetApplicationJson","studyInstanceUID","seriesInstanceUID","transferSyntax","sopInstanceUID","paramString","join","frameNumbers","_httpGetMultipartApplicationOctetStream","sharedMediaTypes","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","_httpGetMultipartImage","_httpGetMultipartVideo","_httpGetImage","_httpGetVideo","_httpGetText","_httpGetApplicationPdf","debug","_httpGetMultipartApplicationDicom","BulkDataURI","queryString","encodeURIComponent","sepIndex","indexOf","mediaTypeType","types","includes","_assertMediaTypeIsValid","fieldValueParts","item","transferSyntaxUID","fieldValue","values","flat","endsWith","expectedMediaTypes","actualType","_parseMediaType","expectedMediaType","expectedType","haveSameType","Set","type","add","from","findSubstring","before","after","beforeIndex","lastIndexOf","undefined","afterIndex","getStudyInstanceUIDFromUri","uri","uid","getSeriesInstanceUIDFromUri","getSOPInstanceUIDFromUri","getFrameNumbersFromUri","numbers","api","utils"],"mappings":"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"}